/*
 * Copyright 2018 Samsung Electronics Co., Ltd. and other contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from 'react';
import PropTypes from 'prop-types';

export default class ChartInfoModal extends React.Component {

  constructor(props) {
    super(props);
  }

  render() {
    const { project, projects } = this.props;

    return (
      <div
        className="modal fade"
        id={`${project.key}-chart-info`}
        tabIndex="-1"
        role="dialog"
        aria-labelledby={`${project.key}-chart-info-label`}
        aria-hidden="true">
        <div className="modal-dialog modal-lg">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title" id={`${project.key}-chart-info-label`}>
                {project.name} chart info
              </h5>
              <button type="button" className="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>

              {project.key === projects.jerryscript.key &&
                <div className="modal-body text-left">
                  <p>
                    <strong>Binary size</strong>
                  </p>
                  <p>
                    A typical binary application has four main sections:
                  </p>
                  <ul>
                    <li>.text - contains the compiled code</li>
                    <li>.rodata - contains the read only data</li>
                    <li>.data - contains the initialized read / write data</li>
                    <li>.bss - contains the uninitialized read / write data</li>
                  </ul>
                  <p>
                    The space occupied by the application is the sum of the first three sections,
                    since .bss is simply initialized with zero. The binary size chart shows the sum of the first three
                    sections which is the required flash memory (disk) space for Jerryscript.
                  </p>
                  <p>
                    There are two types of build created. The first is a <b>minimal-profile</b> build that contains
                    only the neccessary built-in objects that JerryScript requires. The second is a
                    <b>target-profile</b> build, which complies with the es2015-subset.
                  </p>
                </div>
              }

              {project.key === projects.iotjs.key &&
                <div className="modal-body text-left">
                  <p>
                    <strong>Binary size</strong>
                  </p>
                  <p>
                    A typical binary application has four main sections:
                  </p>
                  <ul>
                    <li>.text - contains the compiled code</li>
                    <li>.rodata - contains the read only data</li>
                    <li>.data - contains the initialized read / write data</li>
                    <li>.bss - contains the uninitialized read / write data</li>
                  </ul>
                  <p>
                    The space occupied by the application is the sum of the first three sections,
                    since .bss is simply initialized with zero. The binary size chart shows the sum of the first
                    three sections which is the required flash memory (disk) space for IoT.js.
                  </p>
                  <p>
                    There are two types of build created. The first is a <b>minimal-profile</b> build that contains
                    only the neccessary modules IoT.js requires. The second is a <b>target and test specific profile</b>
                    build, that contains all the modules that the tests require.
                  </p>
                  <p>
                    On TizenRT operating system the system and all applications are compiled into a single binary.
                    The space consumed by IoT.js is calculated from the linker map file generated by the compiler.
                  </p>

                  <p>
                    <strong>Memory measurement setup</strong>
                  </p>
                  <p>
                    IoT.js has three major components:
                  </p>
                  <ul>
                    <li>IoT.js core</li>
                    <li>libtuv</li>
                    <li>JerryScript</li>
                  </ul>
                  <p>
                    The core and libtuv uses the system malloc for allocating memory. However,
                    JerryScript has an own optimized memory allocator with zero allocation overhead
                    (i.e. does not allocate extra space for allocated blocks), so the whole memory area
                    can be allocated by the application. The JerryScript allocator uses a contiguous memory block
                    called JerryScript heap which size can be specified at compile time.
                    The test system uses a 60 KByte JerryScript heap which is enough to run the IoT.js tests.
                  </p>
                  <img
                    className="img-fluid mx-auto d-block"
                    src={require('../../../../public/images/info/average_memory_consumtion.png')} />
                  <p>
                    The average memory chart shows the average memory consumption which is computed by adding the memory
                    allocated by malloc and JerryScript plus the stack size.
                  </p>
                  <p>
                    The average memory consumption of the components above on 10th of November 2017 follows:
                  </p>
                  <ul>
                    <li>JerryScript heap: 26486 Bytes</li>
                    <li>System heap: 3632 Bytes</li>
                    <li>Stack: 4836 Bytes</li>
                  </ul>
                  <p>
                    The percentage of these components can be seen on Figure 1 above.
                    </p>
                  <img
                    className="img-fluid mx-auto d-block"
                    src={require('../../../../public/images/info/minimum_system_requirement.png')} />
                  <p>
                    The minimum memory requirement chart shows the minimum memory settings of the test system when all
                    tests are executed. Any system with these resources are capable of running with the test system:
                  </p>
                  <ul>
                    <li>JerryScript heap: 57344 Bytes (56 KB)</li>
                    <li>System heap: 15808 Bytes</li>
                    <li>Stack: 7800 Bytes</li>
                  </ul>
                  <p>
                    The percentage of these components can be seen on Figure 2 above.
                  </p>
                </div>
              }

            <div className="modal-footer">
              <button type="button" className="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
          </div>
        </div>
      </div>
    );
  }
}

ChartInfoModal.propTypes = {
  project: PropTypes.object.isRequired,
  projects: PropTypes.object.isRequired,
};
